import{a_ as s,o as d,q as O,r as t,C as f,b2 as n}from"./index-DxIfR8rB.js";class i extends s{_getDefaultOptions(){return d(super._getDefaultOptions(),{preventScrollEvents:!1})}_getToolbarName(){return"dxToolbar"}}i.defaultOptions=function(e){s.defaultOptions(e)};O("dxPopup",i);/*!
 * devextreme-react
 * Version: 24.2.3
 * Build date: Fri Dec 06 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-react
 */const x=t.memo(t.forwardRef((e,m)=>{const o=t.useRef(null);t.useImperativeHandle(m,()=>({instance(){var p;return(p=o.current)==null?void 0:p.getInstance()}}),[o.current]);const r=t.useMemo(()=>["height","position","visible","width"],[]),c=t.useMemo(()=>["onContentReady","onDisposing","onHidden","onHiding","onInitialized","onResize","onResizeEnd","onResizeStart","onShowing","onShown","onTitleRendered"],[]),a=t.useMemo(()=>({defaultHeight:"height",defaultPosition:"position",defaultVisible:"visible",defaultWidth:"width"}),[]),l=t.useMemo(()=>({animation:{optionName:"animation",isCollectionItem:!1},position:{optionName:"position",isCollectionItem:!1},toolbarItem:{optionName:"toolbarItems",isCollectionItem:!0}}),[]),u=t.useMemo(()=>[{tmplOption:"contentTemplate",render:"contentRender",component:"contentComponent"},{tmplOption:"titleTemplate",render:"titleRender",component:"titleComponent"}],[]);return t.createElement(f,{WidgetClass:i,ref:o,isPortalComponent:!0,subscribableOptions:r,independentEvents:c,defaults:a,expectedChildren:l,templateProps:u,...e})})),b=e=>t.createElement(n,{...e,elementDescriptor:{OptionName:"animation",ExpectedChildren:{hide:{optionName:"hide",isCollectionItem:!1},show:{optionName:"show",isCollectionItem:!1}}}});Object.assign(b,{componentType:"option"});const g=e=>t.createElement(n,{...e,elementDescriptor:{OptionName:"at"}});Object.assign(g,{componentType:"option"});const C=e=>t.createElement(n,{...e,elementDescriptor:{OptionName:"boundaryOffset"}});Object.assign(C,{componentType:"option"});const N=e=>t.createElement(n,{...e,elementDescriptor:{OptionName:"collision"}});Object.assign(N,{componentType:"option"});const h=e=>t.createElement(n,{...e,elementDescriptor:{OptionName:"from",ExpectedChildren:{position:{optionName:"position",isCollectionItem:!1}}}});Object.assign(h,{componentType:"option"});const T=e=>t.createElement(n,{...e,elementDescriptor:{OptionName:"hide",ExpectedChildren:{from:{optionName:"from",isCollectionItem:!1},to:{optionName:"to",isCollectionItem:!1}}}});Object.assign(T,{componentType:"option"});const E=e=>t.createElement(n,{...e,elementDescriptor:{OptionName:"my"}});Object.assign(E,{componentType:"option"});const I=e=>t.createElement(n,{...e,elementDescriptor:{OptionName:"offset"}});Object.assign(I,{componentType:"option"});const y=e=>t.createElement(n,{...e,elementDescriptor:{OptionName:"position"}});Object.assign(y,{componentType:"option"});const _=e=>t.createElement(n,{...e,elementDescriptor:{OptionName:"show"}});Object.assign(_,{componentType:"option"});const D=e=>t.createElement(n,{...e,elementDescriptor:{OptionName:"to"}});Object.assign(D,{componentType:"option"});const j=e=>t.createElement(n,{...e,elementDescriptor:{OptionName:"toolbarItems",IsCollectionItem:!0,TemplateProps:[{tmplOption:"menuItemTemplate",render:"menuItemRender",component:"menuItemComponent"},{tmplOption:"template",render:"render",component:"component"}]}});Object.assign(j,{componentType:"option"});export{x as P};
